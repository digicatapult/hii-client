{"version":3,"file":"bundle.f3a39cdf2236072bf8b7.js","mappings":";;AAMA;AACA;AAmOA","sources":["webpack://@digicatapult/hii-client/./node_modules/@digicatapult/ui-component-library/lib/Map/index.js"],"sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useRef, useEffect, useMemo } from 'react';\nimport styled from 'styled-components';\nimport mapboxgl from 'mapbox-gl';\nimport colors from '../colors.js';\nconst Wrapper = styled('div') `\n  height: ${({ height }) => height};\n  width: ${({ width }) => width};\n`;\nconst applyLayerDefaults = (props) => {\n    return {\n        cluster: props.cluster || false,\n        clusterOptions: {\n            clusterMaxZoom: props.clusterOptions?.clusterMaxZoom || 14,\n            clusterAreaRadius: props.clusterOptions?.clusterAreaRadius || 50,\n            clusterColor: props.clusterOptions?.clusterColor || colors.black,\n            clusterRadius: props.clusterOptions?.clusterRadius || 20,\n            countFont: props.clusterOptions?.countFont || ['Open Sans Regular'],\n            countFontSize: props.clusterOptions?.countFontSize || 14,\n            countFontColor: props.clusterOptions?.countFontColor || colors.white,\n        },\n        pointOptions: {\n            pointExpression: props.pointOptions?.pointExpression || null,\n            pointColor: props.pointOptions?.pointColor || colors.black,\n            pointRadius: props.pointOptions?.pointRadius || 5,\n            pointRadiusExpression: props.pointOptions?.pointRadiusExpression || null,\n            pointStrokeWidth: props.pointOptions?.pointStrokeWidth || 0,\n            pointStrokeColor: props.pointOptions?.pointStrokeColor || colors.white,\n            onPointClick: props.pointOptions?.onPointClick || Function(),\n            onClickZoomIn: props.pointOptions?.onClickZoomIn || 11,\n        },\n        markerOptions: {\n            markerSearchFocus: props.markerOptions?.markerSearchFocus || false,\n            markerLinear: props.markerOptions?.markerLinear || false,\n            markerMaxZoom: props.markerOptions?.markerMaxZoom || 12,\n            markerSpeed: props.markerOptions?.markerSpeed || 0.6,\n            markerPadding: props.markerOptions?.markerPadding || 100,\n        },\n    };\n};\nconst updateMap = (sourceJson) => {\n    if (sourceJson != null || sourceJson != undefined) {\n        if (sourceJson.features.length > 0) {\n            let bounds = sourceJson.features.reduce(function (bounds, feature) {\n                if (!Array.isArray(feature.geometry.coordinates[0])) {\n                    return bounds.extend(feature.geometry.coordinates);\n                }\n                else {\n                    return feature.geometry.coordinates.reduce(function (bounds, coord) {\n                        return bounds.extend(coord);\n                    }, bounds);\n                }\n            }, new mapboxgl.LngLatBounds());\n            return bounds;\n        }\n    }\n};\nconst Map = (props) => {\n    const mapContainer = useRef(null);\n    const mapRef = useRef(null);\n    const { cluster, clusterOptions: { clusterMaxZoom, clusterAreaRadius, clusterColor, clusterRadius, countFont, countFontSize, countFontColor, }, pointOptions: { pointExpression, pointColor, pointRadius, pointRadiusExpression, pointStrokeWidth, pointStrokeColor, onPointClick, onClickZoomIn, }, markerOptions: { markerSearchFocus, markerLinear, markerMaxZoom, markerSpeed, markerPadding, }, } = applyLayerDefaults(props);\n    const sourceJson = props.sourceJson;\n    const height = props.initialState?.height || '800px';\n    const width = props.initialState?.width || '800px';\n    mapboxgl.accessToken = props.token;\n    const easeSpeed = props?.easeSpeed || 4000; // milliseconds\n    const bounds = useMemo(() => updateMap(sourceJson), [sourceJson]);\n    // initialize map\n    useEffect(() => {\n        if (mapRef.current)\n            return undefined;\n        // defaults\n        const long = props.initialState?.long || -3.5;\n        const lat = props.initialState?.lat || 55;\n        const zoom = props.initialState?.zoom || 5;\n        const style = props.initialState?.style || 'mapbox://styles/mapbox/light-v11';\n        mapRef.current = new mapboxgl.Map({\n            container: mapContainer.current,\n            style: style,\n            center: [long, lat],\n            zoom: zoom,\n            attributionControl: false,\n            testMode: true,\n        });\n        // clean up\n        return () => {\n            mapRef?.current?.remove();\n            mapRef.current = null;\n        };\n    }, [\n        props.initialState?.style,\n        props.initialState?.long,\n        props.initialState?.lat,\n        props.initialState?.zoom,\n        // height/width changes require map reload\n        props.initialState?.height,\n        props.initialState?.width,\n    ]);\n    // update map geojson without map reload\n    useEffect(() => {\n        const map = mapRef.current;\n        if (!map || !sourceJson)\n            return undefined;\n        const geojsonSource = map.getSource('source');\n        geojsonSource?.setData(sourceJson);\n    }, [sourceJson]);\n    // update map fitBound area\n    useEffect(() => {\n        const map = mapRef.current;\n        if (!map || !sourceJson)\n            return undefined;\n        // Update map on search\n        if (markerSearchFocus) {\n            if (bounds != undefined && bounds != null) {\n                {\n                    map.fitBounds(bounds, {\n                        linear: markerLinear,\n                        maxZoom: markerMaxZoom,\n                        speed: markerSpeed,\n                        padding: markerPadding,\n                    });\n                }\n            }\n        }\n    }, [\n        sourceJson,\n        bounds,\n        markerSearchFocus,\n        markerLinear,\n        markerMaxZoom,\n        markerSpeed,\n        markerPadding,\n    ]);\n    // Use to travel to location on card click\n    useEffect(() => {\n        const map = mapRef.current;\n        // Check that map exists before looking to zoom in (given coordinates exist)\n        if (map != null && props?.zoomLocation != null) {\n            map.easeTo({\n                center: props?.zoomLocation,\n                zoom: onClickZoomIn,\n                duration: easeSpeed,\n                essential: true,\n            });\n        }\n    }, [props?.zoomLocation, onClickZoomIn, easeSpeed]);\n    // add layers after map load\n    useEffect(() => {\n        const map = mapRef.current;\n        if (!map)\n            return undefined;\n        map.on('load', () => {\n            map.addSource('source', {\n                type: 'geojson',\n                data: sourceJson,\n                cluster: cluster,\n                clusterMaxZoom: clusterMaxZoom,\n                clusterRadius: clusterAreaRadius, // Radius of each cluster when clustering points\n            });\n            map.addLayer({\n                id: 'clusters',\n                type: 'circle',\n                source: 'source',\n                filter: ['has', 'point_count'],\n                paint: {\n                    'circle-color': clusterColor,\n                    'circle-radius': clusterRadius,\n                },\n            });\n            map.addLayer({\n                id: 'cluster-count',\n                type: 'symbol',\n                source: 'source',\n                filter: ['has', 'point_count'],\n                layout: {\n                    'text-field': ['get', 'point_count_abbreviated'],\n                    'text-font': countFont,\n                    'text-size': countFontSize,\n                },\n                paint: {\n                    'text-color': countFontColor,\n                },\n            });\n            map.addLayer({\n                id: 'unclustered-point',\n                type: 'circle',\n                source: 'source',\n                filter: ['!', ['has', 'point_count']],\n                paint: {\n                    'circle-color': pointExpression != null ? pointExpression : pointColor,\n                    'circle-radius': pointRadiusExpression != null ? pointRadiusExpression : pointRadius,\n                    'circle-stroke-color': pointStrokeColor,\n                    'circle-stroke-width': pointStrokeWidth,\n                },\n            });\n            // inspect a cluster on click\n            map.on('click', 'clusters', (e) => {\n                const features = map.queryRenderedFeatures(e.point, {\n                    layers: ['clusters'],\n                });\n                const clusterId = features[0]?.properties?.cluster_id;\n                const source = map.getSource('source');\n                source.getClusterExpansionZoom(clusterId, (err, zoom) => {\n                    if (err)\n                        return;\n                    if (features[0].geometry.type === 'Point') {\n                        map.easeTo({\n                            center: features[0].geometry.coordinates,\n                            zoom: zoom,\n                        });\n                    }\n                });\n            });\n            map.on('click', 'unclustered-point', (e) => {\n                const features = map.queryRenderedFeatures(e.point);\n                if (features[0].geometry.type === 'Point') {\n                    onPointClick(features[0]);\n                    // center on point, zoom in if current zoom is less than onClickZoomIn\n                    map.easeTo({\n                        center: features[0].geometry.coordinates,\n                        zoom: Math.max(map.getZoom(), onClickZoomIn),\n                    });\n                }\n            });\n            map.on('mouseenter', 'clusters', () => {\n                map.getCanvas().style.cursor = 'pointer';\n            });\n            map.on('mouseleave', 'clusters', () => {\n                map.getCanvas().style.cursor = '';\n            });\n        });\n    });\n    return _jsx(Wrapper, { ref: mapContainer, height: height, width: width });\n};\nexport default Map;\n"],"names":[],"sourceRoot":""}